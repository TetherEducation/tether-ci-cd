name: Deploy Explorer Docker Django Service

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      bootstrap_project_id:
        description: 'Bootstrap GCP Project ID for authentication'
        required: true
        type: string
      bootstrap_project_number:
        description: 'Bootstrap GCP Project Number for Workload Identity'
        required: true
        type: string
      bootstrap_workload_identity_provider:
        description: 'Bootstrap Workload Identity Provider path'
        required: true
        type: string
      bootstrap_service_account:
        description: 'Bootstrap GitHub Actions Service Account email'
        required: true
        type: string
      deployment_config_secret_name:
        description: 'GCP Secret Manager secret name containing deployment configuration'
        required: true
        type: string
      service_name:
        description: 'Internal service name (e.g., core, users)'
        required: true
        type: string
      migration_job_key:
        description: 'Job key for migrations (e.g., core-run-migrations, users-run-migrations)'
        required: true
        type: string
      run_migrations:
        description: 'For workflow_dispatch: Whether to run migrations. For PRs, migrations run automatically if migration files are detected.'
        required: false
        type: boolean
        default: false
      docker_build_args:
        description: 'Docker build arguments as multi-line string'
        required: false
        type: string
        default: ''

permissions:
  contents: read
  id-token: write
  packages: read

jobs:
  prepare:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
    outputs:
      project_id: ${{ steps.config.outputs.project_id }}
      project_number: ${{ steps.config.outputs.project_number }}
      artifact_registry: ${{ steps.config.outputs.artifact_registry }}
      repository: ${{ steps.config.outputs.repository }}
      workload_identity_provider: ${{ steps.config.outputs.workload_identity_provider }}
      github_actions_service_account: ${{ steps.config.outputs.github_actions_service_account }}
      image_tag: ${{ steps.tags.outputs.tag }}
      image_matrix: ${{ steps.tags.outputs.image_matrix }}
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Authenticate to Google Cloud (Bootstrap)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ inputs.bootstrap_workload_identity_provider }}
          service_account: ${{ inputs.bootstrap_service_account }}

      - name: ‚öôÔ∏è Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'
          project_id: ${{ inputs.bootstrap_project_id }}

      - name: üîç Verify Authentication
        run: |
          echo "=== Authentication Verification ==="
          echo "üìã Authenticated accounts:"
          gcloud auth list
          echo ""
          echo "üìã Current project: $(gcloud config get-value project)"
          echo "üìã Service account: $(gcloud config get-value account)"
          echo "üìã Bootstrap project ID: ${{ inputs.bootstrap_project_id }}"
          echo "üìã Bootstrap service account: ${{ inputs.bootstrap_service_account }}"
          echo "üìã Workload Identity Provider: ${{ inputs.bootstrap_workload_identity_provider }}"
          echo ""
          echo "üîê Testing authentication..."
          if gcloud auth print-access-token &>/dev/null; then
            echo "‚úÖ Successfully obtained access token"
            TOKEN_PREFIX=$(gcloud auth print-access-token | cut -c1-20)
            echo "   Token prefix: ${TOKEN_PREFIX}..."
          else
            echo "‚ùå Failed to obtain access token"
            exit 1
          fi

      - name: üì¶ Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: üìñ Read Deployment Configuration from Secret Manager
        id: config
        env:
          SECRET_NAME: ${{ inputs.deployment_config_secret_name }}
          BOOTSTRAP_PROJECT_ID: ${{ inputs.bootstrap_project_id }}
          BOOTSTRAP_SERVICE_ACCOUNT: ${{ inputs.bootstrap_service_account }}
        run: |
          set -e
          echo "=== Secret Access Debugging ==="
          echo ""
          echo "üìã Configuration:"
          echo "   Secret Name: $SECRET_NAME"
          echo "   Project ID: $BOOTSTRAP_PROJECT_ID"
          echo "   Service Account: $BOOTSTRAP_SERVICE_ACCOUNT"
          echo "   Environment: ${{ inputs.environment }}"
          echo ""
          
          echo "üîç Step 1: Verifying gcloud configuration..."
          echo "   Current project: $(gcloud config get-value project)"
          echo "   Current account: $(gcloud config get-value account)"
          echo ""
          
          echo "üîç Step 2: Checking service account permissions..."
          if gcloud projects get-iam-policy "$BOOTSTRAP_PROJECT_ID" --flatten="bindings[].members" --filter="bindings.members:serviceAccount:$BOOTSTRAP_SERVICE_ACCOUNT" --format="table(bindings.role)" 2>/dev/null | grep -q "secretmanager"; then
            echo "   ‚úÖ Service account has Secret Manager permissions"
            gcloud projects get-iam-policy "$BOOTSTRAP_PROJECT_ID" --flatten="bindings[].members" --filter="bindings.members:serviceAccount:$BOOTSTRAP_SERVICE_ACCOUNT" --format="table(bindings.role)" | grep secretmanager || true
          else
            echo "   ‚ö†Ô∏è  Warning: Could not verify Secret Manager permissions (this may be normal if permissions are granted at secret level)"
          fi
          echo ""
          
          echo "üîç Step 3: Checking if secret exists..."
          if gcloud secrets describe "$SECRET_NAME" --project="$BOOTSTRAP_PROJECT_ID" &>/dev/null; then
            echo "   ‚úÖ Secret exists: $SECRET_NAME"
            echo "   Secret details:"
            gcloud secrets describe "$SECRET_NAME" --project="$BOOTSTRAP_PROJECT_ID" --format="yaml(name,createTime,labels)" || true
          else
            SECRET_ERROR=$(gcloud secrets describe "$SECRET_NAME" --project="$BOOTSTRAP_PROJECT_ID" 2>&1 || true)
            echo "   ‚ùå Error accessing secret: $SECRET_NAME"
            echo "   Error details: $SECRET_ERROR"
            echo ""
            echo "   Troubleshooting steps:"
            echo "   1. Verify the secret name is correct: $SECRET_NAME"
            echo "   2. Verify the secret exists in project: $BOOTSTRAP_PROJECT_ID"
            echo "   3. Verify service account $BOOTSTRAP_SERVICE_ACCOUNT has 'Secret Manager Secret Accessor' role"
            echo "   4. Verify Workload Identity Federation is properly configured"
            echo "   5. Check if the secret has IAM bindings that allow this service account"
            exit 1
          fi
          echo ""
          
          echo "üîç Step 4: Reading secret content..."
          echo "   Command: gcloud secrets versions access latest --secret=\"$SECRET_NAME\" --project=\"$BOOTSTRAP_PROJECT_ID\""
          if CONFIG_JSON=$(gcloud secrets versions access latest \
            --secret="$SECRET_NAME" \
            --project="$BOOTSTRAP_PROJECT_ID" 2>&1); then
            echo "   ‚úÖ Successfully read secret"
            CONFIG_SIZE=$(echo "$CONFIG_JSON" | wc -c)
            echo "   Secret size: $CONFIG_SIZE bytes"
            
            # Validate JSON
            if echo "$CONFIG_JSON" | jq empty 2>/dev/null; then
              echo "   ‚úÖ Secret contains valid JSON"
            else
              echo "   ‚ùå Error: Secret does not contain valid JSON"
              echo "   First 200 characters: $(echo "$CONFIG_JSON" | head -c 200)"
              exit 1
            fi
          else
            READ_ERROR="$CONFIG_JSON"
            echo "   ‚ùå Error reading secret content"
            echo "   Error: $READ_ERROR"
            echo ""
            echo "   Common issues:"
            echo "   - Service account lacks 'Secret Manager Secret Accessor' role"
            echo "   - Secret version is disabled or destroyed"
            echo "   - Network/firewall issues"
            exit 1
          fi
          echo ""
          
          echo "üîç Step 5: Parsing configuration..."
          # Extract values using jq with error handling
          PROJECT_ID=$(echo "$CONFIG_JSON" | jq -r '.project_id // empty')
          PROJECT_NUMBER=$(echo "$CONFIG_JSON" | jq -r '.project_number // empty')
          ARTIFACT_REGISTRY_HOST=$(echo "$CONFIG_JSON" | jq -r '.artifact_registry_host // empty')
          ARTIFACT_REGISTRY_REPOSITORY=$(echo "$CONFIG_JSON" | jq -r '.artifact_registry_repository // empty')
          WORKLOAD_IDENTITY_PROVIDER=$(echo "$CONFIG_JSON" | jq -r '.workload_identity_provider // empty')
          GITHUB_ACTIONS_SERVICE_ACCOUNT=$(echo "$CONFIG_JSON" | jq -r '.github_actions_service_account // empty')
          REGIONS=$(echo "$CONFIG_JSON" | jq -r '.regions // empty')
          INFRASTRUCTURE=$(echo "$CONFIG_JSON" | jq -r '.infrastructure // empty')
          
          echo "   Parsed values:"
          echo "   - project_id: ${PROJECT_ID:-‚ùå MISSING}"
          echo "   - project_number: ${PROJECT_NUMBER:-‚ùå MISSING}"
          echo "   - artifact_registry_host: ${ARTIFACT_REGISTRY_HOST:-‚ùå MISSING}"
          echo "   - artifact_registry_repository: ${ARTIFACT_REGISTRY_REPOSITORY:-‚ùå MISSING}"
          echo "   - workload_identity_provider: ${WORKLOAD_IDENTITY_PROVIDER:-‚ùå MISSING}"
          echo "   - github_actions_service_account: ${GITHUB_ACTIONS_SERVICE_ACCOUNT:-‚ùå MISSING}"
          echo "   - regions: ${REGIONS:-‚ùå MISSING}"
          
          if [ -z "$PROJECT_ID" ] || [ -z "$PROJECT_NUMBER" ] || [ -z "$ARTIFACT_REGISTRY_HOST" ] || [ -z "$ARTIFACT_REGISTRY_REPOSITORY" ]; then
            echo ""
            echo "   ‚ùå Error: Required fields are missing from deployment config"
            echo "   Full config structure:"
            echo "$CONFIG_JSON" | jq '.' | head -50
            exit 1
          fi
          
          if [ "$REGIONS" = "null" ] || [ -z "$REGIONS" ]; then
            echo ""
            echo "   ‚ùå Error: 'regions' array is missing or empty in deployment config"
            exit 1
          fi
          
          if [ "$INFRASTRUCTURE" = "null" ] || [ -z "$INFRASTRUCTURE" ]; then
            echo ""
            echo "   ‚ùå Error: 'infrastructure' object is missing in deployment config"
            exit 1
          fi
          
          REGIONS_COUNT=$(echo "$CONFIG_JSON" | jq -r '.regions | length // 0')
          if [ "$REGIONS_COUNT" -eq 0 ]; then
            echo ""
            echo "   ‚ùå Error: No regions defined in deployment config"
            exit 1
          fi
          
          echo ""
          echo "   Regions configuration:"
          SERVICE_NAME_PARAM="${{ inputs.service_name }}"
          MIGRATION_JOB_KEY_PARAM="${{ inputs.migration_job_key }}"
          echo "$CONFIG_JSON" | jq -r '.regions[]' | while read -r region_key; do
            SERVICE_NAME=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".services[\"$SERVICE_NAME_PARAM\"].service_name // \"not set\"")
            REGION=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".region // \"not set\"")
            IMAGE_NAME=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".services[\"$SERVICE_NAME_PARAM\"].image_name // \"not set\"")
            JOB_NAME=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".jobs.\"$MIGRATION_JOB_KEY_PARAM\".job_name // \"not set\"")
            echo "   - $region_key: $SERVICE_NAME in $REGION (image: $IMAGE_NAME, migration job: $JOB_NAME)"
          done
          echo ""
          
          # Set outputs
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "project_number=$PROJECT_NUMBER" >> $GITHUB_OUTPUT
          echo "artifact_registry=$ARTIFACT_REGISTRY_HOST" >> $GITHUB_OUTPUT
          echo "repository=$ARTIFACT_REGISTRY_REPOSITORY" >> $GITHUB_OUTPUT
          echo "workload_identity_provider=$WORKLOAD_IDENTITY_PROVIDER" >> $GITHUB_OUTPUT
          echo "github_actions_service_account=$GITHUB_ACTIONS_SERVICE_ACCOUNT" >> $GITHUB_OUTPUT
          
          # Store full JSON for later use
          echo "$CONFIG_JSON" > /tmp/deployment-config.json
          echo "‚úÖ Configuration successfully parsed and stored"

      - name: üè∑Ô∏è Generate image tags
        id: tags
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}"
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

          # Extract unique image_name values from all regions
          echo "üîç Extracting unique image names from all regions..."
          SERVICE_NAME_PARAM="${{ inputs.service_name }}"
          IMAGE_MATRIX=$(cat /tmp/deployment-config.json | jq -c --arg service_name "$SERVICE_NAME_PARAM" '[.regions[] as $region_key | .infrastructure[$region_key].services[$service_name].image_name] | unique | map({image_name: .})')
          IMAGE_MATRIX_COUNT=$(echo "$IMAGE_MATRIX" | jq 'length')
          
          echo "‚úÖ Found $IMAGE_MATRIX_COUNT unique image(s):"
          echo "$IMAGE_MATRIX" | jq -r '.[] | "   - \(.image_name)"'
          
          # Export image matrix
          echo "image_matrix=$IMAGE_MATRIX" >> $GITHUB_OUTPUT

      - name: üî® Build Deployment Matrix
        id: matrix
        run: |
          # Build matrix from regions array and infrastructure object
          SERVICE_NAME_PARAM="${{ inputs.service_name }}"
          MIGRATION_JOB_KEY_PARAM="${{ inputs.migration_job_key }}"
          MATRIX=$(cat /tmp/deployment-config.json | jq -c --arg service_name "$SERVICE_NAME_PARAM" --arg migration_job_key "$MIGRATION_JOB_KEY_PARAM" '[.regions[] as $region_key | {
            label: $region_key,
            service_name: .infrastructure[$region_key].services[$service_name].service_name,
            region: .infrastructure[$region_key].region,
            image_name: .infrastructure[$region_key].services[$service_name].image_name,
            migration_job_name: .infrastructure[$region_key].jobs[$migration_job_key].job_name
          }]')
          
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Built matrix with $(echo "$MATRIX" | jq 'length') regions:"
          echo "$MATRIX" | jq -r '.[] | "  - \(.label): \(.service_name) in \(.region) (image: \(.image_name), migration job: \(.migration_job_name))"'
          
          # Validate that all required fields exist
          MISSING_SERVICE=$(echo "$MATRIX" | jq -r '.[] | select(.service_name == null or .service_name == "") | .label')
          MISSING_REGION=$(echo "$MATRIX" | jq -r '.[] | select(.region == null or .region == "") | .label')
          MISSING_IMAGE=$(echo "$MATRIX" | jq -r '.[] | select(.image_name == null or .image_name == "") | .label')
          MISSING_JOB=$(echo "$MATRIX" | jq -r '.[] | select(.migration_job_name == null or .migration_job_name == "") | .label')
          
          if [ -n "$MISSING_SERVICE" ]; then
            echo "‚ùå Error: Some regions are missing $SERVICE_NAME_PARAM service:"
            echo "$MISSING_SERVICE"
            exit 1
          fi
          
          if [ -n "$MISSING_REGION" ]; then
            echo "‚ùå Error: Some regions are missing GCP region:"
            echo "$MISSING_REGION"
            exit 1
          fi
          
          if [ -n "$MISSING_IMAGE" ]; then
            echo "‚ùå Error: Some regions are missing image_name:"
            echo "$MISSING_IMAGE"
            exit 1
          fi
          
          if [ -n "$MISSING_JOB" ]; then
            echo "‚ùå Error: Some regions are missing $MIGRATION_JOB_KEY_PARAM job:"
            echo "$MISSING_JOB"
            exit 1
          fi

  build:
    needs: prepare
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.image_matrix) }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.prepare.outputs.workload_identity_provider }}
          service_account: ${{ needs.prepare.outputs.github_actions_service_account }}

      - name: ‚öôÔ∏è Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'

      - name: üîë Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ needs.prepare.outputs.artifact_registry }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ========== CACHE OPTIMIZATION: Python/Django Build Cache ==========
      - name: üíæ Setup Python Build Cache for Docker
        id: cache-python
        uses: actions/cache@v4
        with:
          path: python-build-cache-${{ matrix.image_name }}
          key: ${{ runner.os }}-python-build-cache-${{ matrix.image_name }}-v2-${{ hashFiles('Pipfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-python-build-cache-${{ matrix.image_name }}-v2-

      - name: üîÑ Inject Python Build Cache into Docker
        uses: reproducible-containers/buildkit-cache-dance@v3.1.2
        with:
          cache-map: |
            {
              "python-build-cache-${{ matrix.image_name }}": "/root/.cache/pip"
            }
          skip-extraction: false
      # ====================================================================

      - name: üîß Prepare Docker Build Args
        id: build_args
        run: |
          if [ -n "${{ inputs.docker_build_args }}" ] && [ "${{ inputs.docker_build_args }}" != "" ]; then
            echo "Using custom docker_build_args from input"
            BUILD_ARGS="${{ inputs.docker_build_args }}"
          else
            echo "Using default docker_build_args"
            BUILD_ARGS=$(printf '%s\n' \
              "INPUT_ENVIRONMENT=${{ inputs.environment }}" \
              "INPUT_LOGDNA_INGESTION_KEY=${{ secrets.LOGDNA_INGESTION_KEY }}" \
              "INPUT_AWS_ACCESS=${{ secrets.AWS_ACCESS_KEY_ID }}" \
              "INPUT_AWS_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
              "INPUT_AWS_REGION=${{ secrets.AWS_DEFAULT_REGION }}" \
              "INPUT_GITHUB_TOKEN=${{ secrets.GH_PAT }}" \
              "INPUT_DEPLOY_REGION=default" \
              "INPUT_PROVIDER=gcp")
          fi
          # Store in output (using delimiter to preserve newlines)
          {
            echo 'args<<EOF'
            echo "$BUILD_ARGS"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: üèóÔ∏è Build and Push Docker image for ${{ matrix.image_name }}
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          build-args: ${{ steps.build_args.outputs.args }}
          cache-from: |
            type=gha,scope=${{ matrix.image_name }}
            type=registry,ref=${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:cache
          cache-to: |
            type=gha,scope=${{ matrix.image_name }},mode=max
            type=registry,ref=${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:cache,mode=max,oci-mediatypes=true
          tags: |
            ${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:${{ needs.prepare.outputs.image_tag }}
            ${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:latest
            ${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:${{ inputs.environment }}-latest

  label-migrations:
    needs: [prepare]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
    outputs:
      has_migrations: ${{ steps.check_migrations.outputs.has_migrations }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for migration detection

      - name: üîç Check for Migration File Changes
        id: check_migrations
        run: |
          echo "üîç Checking for migration file changes..."
          echo "Current SHA: $GITHUB_SHA"
          echo "Event name: ${{ github.event_name }}"
          
          # Determine the base reference for comparison
          # For PR context, check if we can access PR information
          if [ -n "${{ github.event.pull_request.base.sha }}" ]; then
            BASE_REF="${{ github.event.pull_request.base.sha }}"
            echo "Comparing against PR base: $BASE_REF"
          else
            # For non-PR events (workflow_dispatch, push, etc.), compare against previous commit
            BASE_REF=$(git rev-parse "$GITHUB_SHA^" 2>/dev/null || echo "")
            if [ -z "$BASE_REF" ]; then
              echo "No parent commit found, checking if migrations exist in current commit"
              if git ls-tree -r --name-only "$GITHUB_SHA" | grep -E "(migrations/.*\.py)" | grep -v "__pycache__" | grep -v "__init__\.py" | head -1 > /dev/null; then
                echo "has_migrations=true" >> $GITHUB_OUTPUT
                echo "‚úÖ Migration files found in initial commit"
                exit 0
              else
                echo "has_migrations=false" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è No migration files found"
                exit 0
              fi
            fi
            echo "Comparing against previous commit: $BASE_REF"
          fi
          
          # Check if there are any migration file changes
          MIGRATION_CHANGES=$(git diff --name-only "$BASE_REF" "$GITHUB_SHA" | grep -E "(migrations/.*\.py)" | grep -v "__pycache__" | grep -v "__init__\.py" || true)
          
          if [ -n "$MIGRATION_CHANGES" ]; then
            echo "‚úÖ Migration files changed:"
            echo "$MIGRATION_CHANGES"
            echo "has_migrations=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No migration files changed"
            echo "has_migrations=false" >> $GITHUB_OUTPUT
          fi

  check-migrations:
    needs: [prepare, label-migrations]
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.decide.outputs.should_run }}
    steps:
      - name: üîç Determine if Migrations Should Run
        id: decide
        run: |
          # Check if this is a PR context (workflow_call triggered from PR)
          # For PRs, use file detection from label-migrations job
          # For workflow_dispatch, use the run_migrations input parameter
          
          if [ -n "${{ github.event.pull_request.base.sha }}" ]; then
            # PR context: use file detection result
            MIGRATIONS_DETECTED="${{ needs.label-migrations.outputs.has_migrations }}"
            if [ "$MIGRATIONS_DETECTED" = "true" ]; then
              echo "‚úÖ PR context: Migration files detected - migrations will run"
              echo "should_run=true" >> $GITHUB_OUTPUT
            else
              echo "‚è≠Ô∏è PR context: No migration files detected - migrations will be skipped"
              echo "should_run=false" >> $GITHUB_OUTPUT
            fi
          else
            # workflow_dispatch context: use input parameter
            if [ "${{ inputs.run_migrations }}" = "true" ]; then
              echo "‚úÖ workflow_dispatch: run_migrations=true - migrations will run"
              echo "should_run=true" >> $GITHUB_OUTPUT
            else
              echo "‚è≠Ô∏è workflow_dispatch: run_migrations=false - migrations will be skipped"
              echo "should_run=false" >> $GITHUB_OUTPUT
            fi
          fi

  migrate:
    needs: [prepare, build, label-migrations, check-migrations]
    if: needs.check-migrations.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for migration detection

      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.prepare.outputs.workload_identity_provider }}
          service_account: ${{ needs.prepare.outputs.github_actions_service_account }}

      - name: ‚öôÔ∏è Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'

      - name: üóÑÔ∏è Run Database Migrations for ${{ matrix.label }}
        run: |
          echo "Running migrations for region: ${{ matrix.region }}, label: ${{ matrix.label }}"
          
          PROJECT_ID="${{ needs.prepare.outputs.project_id }}"
          JOB_NAME="${{ matrix.migration_job_name }}"
          
          if [ -z "$JOB_NAME" ] || [ "$JOB_NAME" = "null" ]; then
            echo "‚ùå Migration job name not found for label ${{ matrix.label }}"
            echo "‚ö†Ô∏è  Make sure migration_job_name is set in deployment config for this service"
            exit 1
          fi
          
          echo "Using migration job: $JOB_NAME"
          echo "Region: ${{ matrix.region }}"
          
          # Execute migration job - ENTRYPOINT_MODE=migrate is already set in the job definition
          echo "Executing migration job: $JOB_NAME"
          if ! gcloud run jobs execute "$JOB_NAME" \
            --region "${{ matrix.region }}" \
            --project "$PROJECT_ID" \
            --wait; then
            echo "‚ùå Migration job execution failed"
            echo "üìã View logs: gcloud run jobs executions list --job=$JOB_NAME --region=${{ matrix.region }} --project=$PROJECT_ID"
            exit 1
          fi
          
          echo "‚úÖ Migrations completed successfully for ${{ matrix.label }}"

  deploy:
    needs: [prepare, build, migrate]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.prepare.outputs.workload_identity_provider }}
          service_account: ${{ needs.prepare.outputs.github_actions_service_account }}

      - name: ‚öôÔ∏è Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'

      - name: üöÄ Deploy ${{ matrix.service_name }} to ${{ matrix.region }}
        run: |
          echo "Deploying ${{ matrix.service_name }} to region ${{ matrix.region }}"
          echo "Label: ${{ matrix.label }}"
          
          # Reuse variables from prepare job
          PROJECT_ID="${{ needs.prepare.outputs.project_id }}"
          PROJECT_NUMBER="${{ needs.prepare.outputs.project_number }}"
          ARTIFACT_REGISTRY_HOST="${{ needs.prepare.outputs.artifact_registry }}"
          ARTIFACT_REGISTRY_REPOSITORY="${{ needs.prepare.outputs.repository }}"
          IMAGE_TAG="${{ needs.prepare.outputs.image_tag }}"
          
          # Use image_name from service matrix
          echo "Using image from service matrix: ${{ matrix.image_name }}"
          
          # Construct image path using image_name from service matrix
          IMAGE="${ARTIFACT_REGISTRY_HOST}/${PROJECT_ID}/${ARTIFACT_REGISTRY_REPOSITORY}/${{ matrix.image_name }}"
          
          # Determine DEPLOY_REGION based on label
          if [ "${{ matrix.label }}" = "europe" ] || [ "${{ matrix.label }}" = "eu" ]; then
            DEPLOY_REGION="europe"
          else
            DEPLOY_REGION="default"
          fi
          
          # Build env vars string (only update what's needed, preserve existing Cloud Run vars like K_SERVICE, K_REVISION, PORT, GOOGLE_CLOUD_PROJECT)
          # Use environment variables for entrypoint configuration (ENTRYPOINT_MODE, ENTRYPOINT_PROVIDER)
          ENV_VARS="GOOGLE_CLOUD_PROJECT_NUMBER=$PROJECT_NUMBER,GOOGLE_CLOUD_PROJECT_ID=$PROJECT_ID,DEPLOY_REGION=$DEPLOY_REGION,ENTRYPOINT_MODE=serve,ENTRYPOINT_PROVIDER=gcp"
          
          gcloud run services update "${{ matrix.service_name }}" \
            --image "$IMAGE:$IMAGE_TAG" \
            --region "${{ matrix.region }}" \
            --project "$PROJECT_ID" \
            --update-env-vars "$ENV_VARS"

      - name: üìä Deployment Summary for ${{ matrix.label }}
        run: |
          ARTIFACT_REGISTRY_HOST="${{ needs.prepare.outputs.artifact_registry }}"
          PROJECT_ID="${{ needs.prepare.outputs.project_id }}"
          ARTIFACT_REGISTRY_REPOSITORY="${{ needs.prepare.outputs.repository }}"
          IMAGE_PATH="${ARTIFACT_REGISTRY_HOST}/${PROJECT_ID}/${ARTIFACT_REGISTRY_REPOSITORY}/${{ matrix.image_name }}"
          
          echo "### üöÄ Cloud Run Deployment - ${{ matrix.label }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** ${{ matrix.service_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ matrix.region }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${IMAGE_PATH}:${{ needs.prepare.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY

