name: Deploy Explorer Docker Django Service

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      bootstrap_project_id:
        description: 'Bootstrap GCP Project ID for authentication'
        required: true
        type: string
      bootstrap_project_number:
        description: 'Bootstrap GCP Project Number for Workload Identity'
        required: true
        type: string
      bootstrap_workload_identity_provider:
        description: 'Bootstrap Workload Identity Provider path'
        required: true
        type: string
      bootstrap_service_account:
        description: 'Bootstrap GitHub Actions Service Account email'
        required: true
        type: string
      deployment_config_secret_name:
        description: 'GCP Secret Manager secret name containing deployment configuration'
        required: true
        type: string
      service_name:
        description: 'Internal service name (e.g., core, users)'
        required: true
        type: string
      migration_job_key:
        description: 'Job key for migrations (e.g., core-run-migrations, users-run-migrations)'
        required: true
        type: string
      migrations_require_label:
        description: 'If true, migrations only run when migration label is present. If false, migrations run based on file detection.'
        required: false
        type: boolean
        default: false
      docker_build_args:
        description: 'Docker build arguments as multi-line string'
        required: false
        type: string
        default: ''

permissions:
  contents: read
  id-token: write
  packages: read
  pull-requests: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
    outputs:
      project_id: ${{ steps.config.outputs.project_id }}
      project_number: ${{ steps.config.outputs.project_number }}
      artifact_registry: ${{ steps.config.outputs.artifact_registry }}
      repository: ${{ steps.config.outputs.repository }}
      workload_identity_provider: ${{ steps.config.outputs.workload_identity_provider }}
      github_actions_service_account: ${{ steps.config.outputs.github_actions_service_account }}
      image_tag: ${{ steps.tags.outputs.tag }}
      image_matrix: ${{ steps.tags.outputs.image_matrix }}
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Authenticate to Google Cloud (Bootstrap)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ inputs.bootstrap_workload_identity_provider }}
          service_account: ${{ inputs.bootstrap_service_account }}

      - name: âš™ï¸ Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'
          project_id: ${{ inputs.bootstrap_project_id }}

      - name: ðŸ” Verify Authentication
        run: |
          echo "=== Authentication Verification ==="
          echo "ðŸ“‹ Authenticated accounts:"
          gcloud auth list
          echo ""
          echo "ðŸ“‹ Current project: $(gcloud config get-value project)"
          echo "ðŸ“‹ Service account: $(gcloud config get-value account)"
          echo "ðŸ“‹ Bootstrap project ID: ${{ inputs.bootstrap_project_id }}"
          echo "ðŸ“‹ Bootstrap service account: ${{ inputs.bootstrap_service_account }}"
          echo "ðŸ“‹ Workload Identity Provider: ${{ inputs.bootstrap_workload_identity_provider }}"
          echo ""
          echo "ðŸ” Testing authentication..."
          if gcloud auth print-access-token &>/dev/null; then
            echo "âœ… Successfully obtained access token"
            TOKEN_PREFIX=$(gcloud auth print-access-token | cut -c1-20)
            echo "   Token prefix: ${TOKEN_PREFIX}..."
          else
            echo "âŒ Failed to obtain access token"
            exit 1
          fi

      - name: ðŸ“¦ Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: ðŸ“– Read Deployment Configuration from Secret Manager
        id: config
        env:
          SECRET_NAME: ${{ inputs.deployment_config_secret_name }}
          BOOTSTRAP_PROJECT_ID: ${{ inputs.bootstrap_project_id }}
          BOOTSTRAP_SERVICE_ACCOUNT: ${{ inputs.bootstrap_service_account }}
        run: |
          set -e
          echo "=== Secret Access Debugging ==="
          echo ""
          echo "ðŸ“‹ Configuration:"
          echo "   Secret Name: $SECRET_NAME"
          echo "   Project ID: $BOOTSTRAP_PROJECT_ID"
          echo "   Service Account: $BOOTSTRAP_SERVICE_ACCOUNT"
          echo "   Environment: ${{ inputs.environment }}"
          echo ""
          
          echo "ðŸ” Step 1: Verifying gcloud configuration..."
          echo "   Current project: $(gcloud config get-value project)"
          echo "   Current account: $(gcloud config get-value account)"
          echo ""
          
          echo "ðŸ” Step 2: Checking service account permissions..."
          if gcloud projects get-iam-policy "$BOOTSTRAP_PROJECT_ID" --flatten="bindings[].members" --filter="bindings.members:serviceAccount:$BOOTSTRAP_SERVICE_ACCOUNT" --format="table(bindings.role)" 2>/dev/null | grep -q "secretmanager"; then
            echo "   âœ… Service account has Secret Manager permissions"
            gcloud projects get-iam-policy "$BOOTSTRAP_PROJECT_ID" --flatten="bindings[].members" --filter="bindings.members:serviceAccount:$BOOTSTRAP_SERVICE_ACCOUNT" --format="table(bindings.role)" | grep secretmanager || true
          else
            echo "   âš ï¸  Warning: Could not verify Secret Manager permissions (this may be normal if permissions are granted at secret level)"
          fi
          echo ""
          
          echo "ðŸ” Step 3: Checking if secret exists..."
          if gcloud secrets describe "$SECRET_NAME" --project="$BOOTSTRAP_PROJECT_ID" &>/dev/null; then
            echo "   âœ… Secret exists: $SECRET_NAME"
            echo "   Secret details:"
            gcloud secrets describe "$SECRET_NAME" --project="$BOOTSTRAP_PROJECT_ID" --format="yaml(name,createTime,labels)" || true
          else
            SECRET_ERROR=$(gcloud secrets describe "$SECRET_NAME" --project="$BOOTSTRAP_PROJECT_ID" 2>&1 || true)
            echo "   âŒ Error accessing secret: $SECRET_NAME"
            echo "   Error details: $SECRET_ERROR"
            echo ""
            echo "   Troubleshooting steps:"
            echo "   1. Verify the secret name is correct: $SECRET_NAME"
            echo "   2. Verify the secret exists in project: $BOOTSTRAP_PROJECT_ID"
            echo "   3. Verify service account $BOOTSTRAP_SERVICE_ACCOUNT has 'Secret Manager Secret Accessor' role"
            echo "   4. Verify Workload Identity Federation is properly configured"
            echo "   5. Check if the secret has IAM bindings that allow this service account"
            exit 1
          fi
          echo ""
          
          echo "ðŸ” Step 4: Reading secret content..."
          echo "   Command: gcloud secrets versions access latest --secret=\"$SECRET_NAME\" --project=\"$BOOTSTRAP_PROJECT_ID\""
          if CONFIG_JSON=$(gcloud secrets versions access latest \
            --secret="$SECRET_NAME" \
            --project="$BOOTSTRAP_PROJECT_ID" 2>&1); then
            echo "   âœ… Successfully read secret"
            CONFIG_SIZE=$(echo "$CONFIG_JSON" | wc -c)
            echo "   Secret size: $CONFIG_SIZE bytes"
            
            # Validate JSON
            if echo "$CONFIG_JSON" | jq empty 2>/dev/null; then
              echo "   âœ… Secret contains valid JSON"
            else
              echo "   âŒ Error: Secret does not contain valid JSON"
              echo "   First 200 characters: $(echo "$CONFIG_JSON" | head -c 200)"
              exit 1
            fi
          else
            READ_ERROR="$CONFIG_JSON"
            echo "   âŒ Error reading secret content"
            echo "   Error: $READ_ERROR"
            echo ""
            echo "   Common issues:"
            echo "   - Service account lacks 'Secret Manager Secret Accessor' role"
            echo "   - Secret version is disabled or destroyed"
            echo "   - Network/firewall issues"
            exit 1
          fi
          echo ""
          
          echo "ðŸ” Step 5: Parsing configuration..."
          # Extract values using jq with error handling
          PROJECT_ID=$(echo "$CONFIG_JSON" | jq -r '.project_id // empty')
          PROJECT_NUMBER=$(echo "$CONFIG_JSON" | jq -r '.project_number // empty')
          ARTIFACT_REGISTRY_HOST=$(echo "$CONFIG_JSON" | jq -r '.artifact_registry_host // empty')
          ARTIFACT_REGISTRY_REPOSITORY=$(echo "$CONFIG_JSON" | jq -r '.artifact_registry_repository // empty')
          WORKLOAD_IDENTITY_PROVIDER=$(echo "$CONFIG_JSON" | jq -r '.workload_identity_provider // empty')
          GITHUB_ACTIONS_SERVICE_ACCOUNT=$(echo "$CONFIG_JSON" | jq -r '.github_actions_service_account // empty')
          REGIONS=$(echo "$CONFIG_JSON" | jq -r '.regions // empty')
          INFRASTRUCTURE=$(echo "$CONFIG_JSON" | jq -r '.infrastructure // empty')
          
          echo "   Parsed values:"
          echo "   - project_id: ${PROJECT_ID:-âŒ MISSING}"
          echo "   - project_number: ${PROJECT_NUMBER:-âŒ MISSING}"
          echo "   - artifact_registry_host: ${ARTIFACT_REGISTRY_HOST:-âŒ MISSING}"
          echo "   - artifact_registry_repository: ${ARTIFACT_REGISTRY_REPOSITORY:-âŒ MISSING}"
          echo "   - workload_identity_provider: ${WORKLOAD_IDENTITY_PROVIDER:-âŒ MISSING}"
          echo "   - github_actions_service_account: ${GITHUB_ACTIONS_SERVICE_ACCOUNT:-âŒ MISSING}"
          echo "   - regions: ${REGIONS:-âŒ MISSING}"
          
          if [ -z "$PROJECT_ID" ] || [ -z "$PROJECT_NUMBER" ] || [ -z "$ARTIFACT_REGISTRY_HOST" ] || [ -z "$ARTIFACT_REGISTRY_REPOSITORY" ]; then
            echo ""
            echo "   âŒ Error: Required fields are missing from deployment config"
            echo "   Full config structure:"
            echo "$CONFIG_JSON" | jq '.' | head -50
            exit 1
          fi
          
          if [ "$REGIONS" = "null" ] || [ -z "$REGIONS" ]; then
            echo ""
            echo "   âŒ Error: 'regions' array is missing or empty in deployment config"
            exit 1
          fi
          
          if [ "$INFRASTRUCTURE" = "null" ] || [ -z "$INFRASTRUCTURE" ]; then
            echo ""
            echo "   âŒ Error: 'infrastructure' object is missing in deployment config"
            exit 1
          fi
          
          REGIONS_COUNT=$(echo "$CONFIG_JSON" | jq -r '.regions | length // 0')
          if [ "$REGIONS_COUNT" -eq 0 ]; then
            echo ""
            echo "   âŒ Error: No regions defined in deployment config"
            exit 1
          fi
          
          echo ""
          echo "   Regions configuration:"
          SERVICE_NAME_PARAM="${{ inputs.service_name }}"
          MIGRATION_JOB_KEY_PARAM="${{ inputs.migration_job_key }}"
          echo "$CONFIG_JSON" | jq -r '.regions[]' | while read -r region_key; do
            SERVICE_NAME=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".services[\"$SERVICE_NAME_PARAM\"].service_name // \"not set\"")
            REGION=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".region // \"not set\"")
            IMAGE_NAME=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".services[\"$SERVICE_NAME_PARAM\"].image_name // \"not set\"")
            JOB_NAME=$(echo "$CONFIG_JSON" | jq -r ".infrastructure.\"$region_key\".jobs.\"$MIGRATION_JOB_KEY_PARAM\".job_name // \"not set\"")
            echo "   - $region_key: $SERVICE_NAME in $REGION (image: $IMAGE_NAME, migration job: $JOB_NAME)"
          done
          echo ""
          
          # Set outputs
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "project_number=$PROJECT_NUMBER" >> $GITHUB_OUTPUT
          echo "artifact_registry=$ARTIFACT_REGISTRY_HOST" >> $GITHUB_OUTPUT
          echo "repository=$ARTIFACT_REGISTRY_REPOSITORY" >> $GITHUB_OUTPUT
          echo "workload_identity_provider=$WORKLOAD_IDENTITY_PROVIDER" >> $GITHUB_OUTPUT
          echo "github_actions_service_account=$GITHUB_ACTIONS_SERVICE_ACCOUNT" >> $GITHUB_OUTPUT
          
          # Store full JSON for later use
          echo "$CONFIG_JSON" > /tmp/deployment-config.json
          echo "âœ… Configuration successfully parsed and stored"

      - name: ðŸ·ï¸ Generate image tags
        id: tags
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}"
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

          # Extract unique image_name values from all regions
          echo "ðŸ” Extracting unique image names from all regions..."
          SERVICE_NAME_PARAM="${{ inputs.service_name }}"
          IMAGE_MATRIX=$(cat /tmp/deployment-config.json | jq -c --arg service_name "$SERVICE_NAME_PARAM" '[.regions[] as $region_key | .infrastructure[$region_key].services[$service_name].image_name] | unique | map({image_name: .})')
          IMAGE_MATRIX_COUNT=$(echo "$IMAGE_MATRIX" | jq 'length')
          
          echo "âœ… Found $IMAGE_MATRIX_COUNT unique image(s):"
          echo "$IMAGE_MATRIX" | jq -r '.[] | "   - \(.image_name)"'
          
          # Export image matrix
          echo "image_matrix=$IMAGE_MATRIX" >> $GITHUB_OUTPUT

      - name: ðŸ”¨ Build Deployment Matrix
        id: matrix
        run: |
          # Build matrix from regions array and infrastructure object
          SERVICE_NAME_PARAM="${{ inputs.service_name }}"
          MIGRATION_JOB_KEY_PARAM="${{ inputs.migration_job_key }}"
          MATRIX=$(cat /tmp/deployment-config.json | jq -c --arg service_name "$SERVICE_NAME_PARAM" --arg migration_job_key "$MIGRATION_JOB_KEY_PARAM" '[.regions[] as $region_key | {
            label: $region_key,
            service_name: .infrastructure[$region_key].services[$service_name].service_name,
            region: .infrastructure[$region_key].region,
            image_name: .infrastructure[$region_key].services[$service_name].image_name,
            migration_job_name: .infrastructure[$region_key].jobs[$migration_job_key].job_name
          }]')
          
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Built matrix with $(echo "$MATRIX" | jq 'length') regions:"
          echo "$MATRIX" | jq -r '.[] | "  - \(.label): \(.service_name) in \(.region) (image: \(.image_name), migration job: \(.migration_job_name))"'
          
          # Validate that all required fields exist
          MISSING_SERVICE=$(echo "$MATRIX" | jq -r '.[] | select(.service_name == null or .service_name == "") | .label')
          MISSING_REGION=$(echo "$MATRIX" | jq -r '.[] | select(.region == null or .region == "") | .label')
          MISSING_IMAGE=$(echo "$MATRIX" | jq -r '.[] | select(.image_name == null or .image_name == "") | .label')
          MISSING_JOB=$(echo "$MATRIX" | jq -r '.[] | select(.migration_job_name == null or .migration_job_name == "") | .label')
          
          if [ -n "$MISSING_SERVICE" ]; then
            echo "âŒ Error: Some regions are missing $SERVICE_NAME_PARAM service:"
            echo "$MISSING_SERVICE"
            exit 1
          fi
          
          if [ -n "$MISSING_REGION" ]; then
            echo "âŒ Error: Some regions are missing GCP region:"
            echo "$MISSING_REGION"
            exit 1
          fi
          
          if [ -n "$MISSING_IMAGE" ]; then
            echo "âŒ Error: Some regions are missing image_name:"
            echo "$MISSING_IMAGE"
            exit 1
          fi
          
          if [ -n "$MISSING_JOB" ]; then
            echo "âŒ Error: Some regions are missing $MIGRATION_JOB_KEY_PARAM job:"
            echo "$MISSING_JOB"
            exit 1
          fi

  build:
    needs: prepare
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.image_matrix) }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.prepare.outputs.workload_identity_provider }}
          service_account: ${{ needs.prepare.outputs.github_actions_service_account }}

      - name: âš™ï¸ Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'

      - name: ðŸ”‘ Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ needs.prepare.outputs.artifact_registry }}

      - name: ðŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ========== CACHE OPTIMIZATION: Python/Django Build Cache ==========
      - name: ðŸ’¾ Setup Python Build Cache for Docker
        id: cache-python
        uses: actions/cache@v4
        with:
          path: python-build-cache-${{ matrix.image_name }}
          key: ${{ runner.os }}-python-build-cache-${{ matrix.image_name }}-v2-${{ hashFiles('Pipfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-python-build-cache-${{ matrix.image_name }}-v2-

      - name: ðŸ”„ Inject Python Build Cache into Docker
        uses: reproducible-containers/buildkit-cache-dance@v3.1.2
        with:
          cache-map: |
            {
              "python-build-cache-${{ matrix.image_name }}": "/root/.cache/pip"
            }
          skip-extraction: false
      # ====================================================================

      - name: ðŸ—ï¸ Build and Push Docker image for ${{ matrix.image_name }}
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          build-args: ${{ inputs.docker_build_args != '' && inputs.docker_build_args || 'INPUT_ENVIRONMENT=${{ inputs.environment }}
            INPUT_LOGDNA_INGESTION_KEY=${{ secrets.LOGDNA_INGESTION_KEY }}
            INPUT_AWS_ACCESS=${{ secrets.AWS_ACCESS_KEY_ID }}
            INPUT_AWS_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            INPUT_AWS_REGION=${{ secrets.AWS_DEFAULT_REGION }}
            INPUT_GITHUB_TOKEN=${{ secrets.GH_PAT }}
            INPUT_DEPLOY_REGION=default
            INPUT_PROVIDER=gcp' }}
          cache-from: |
            type=gha,scope=${{ matrix.image_name }}
            type=registry,ref=${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:cache
          cache-to: |
            type=gha,scope=${{ matrix.image_name }},mode=max
            type=registry,ref=${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:cache,mode=max,oci-mediatypes=true
          tags: |
            ${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:${{ needs.prepare.outputs.image_tag }}
            ${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:latest
            ${{ needs.prepare.outputs.artifact_registry }}/${{ needs.prepare.outputs.project_id }}/${{ needs.prepare.outputs.repository }}/${{ matrix.image_name }}:${{ inputs.environment }}-latest

  label-migrations:
    needs: [prepare]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for migration detection

      - name: ðŸ” Check for Migration File Changes
        id: check_migrations
        run: |
          echo "ðŸ” Checking for migration file changes..."
          echo "Current SHA: $GITHUB_SHA"
          echo "Event name: ${{ github.event_name }}"
          
          # Determine the base reference for comparison
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF="${{ github.event.pull_request.base.sha }}"
            echo "Comparing against PR base: $BASE_REF"
          else
            BASE_REF=$(git rev-parse "$GITHUB_SHA^" 2>/dev/null || echo "")
            if [ -z "$BASE_REF" ]; then
              echo "No parent commit found, checking if migrations exist in current commit"
              if git ls-tree -r --name-only "$GITHUB_SHA" | grep -E "(migrations/.*\.py)" | grep -v "__pycache__" | grep -v "__init__\.py" | head -1 > /dev/null; then
                echo "has_migrations=true" >> $GITHUB_OUTPUT
                echo "âœ… Migration files found in initial commit"
                exit 0
              else
                echo "has_migrations=false" >> $GITHUB_OUTPUT
                echo "â„¹ï¸ No migration files found"
                exit 0
              fi
            fi
            echo "Comparing against previous commit: $BASE_REF"
          fi
          
          # Check if there are any migration file changes
          MIGRATION_CHANGES=$(git diff --name-only "$BASE_REF" "$GITHUB_SHA" | grep -E "(migrations/.*\.py)" | grep -v "__pycache__" | grep -v "__init__\.py" || true)
          
          if [ -n "$MIGRATION_CHANGES" ]; then
            echo "âœ… Migration files changed:"
            echo "$MIGRATION_CHANGES"
            echo "has_migrations=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ No migration files changed"
            echo "has_migrations=false" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ·ï¸ Add Migration Label to PR
        if: steps.check_migrations.outputs.has_migrations == 'true' && github.event_name == 'pull_request'
        uses: actions/labeler@v6
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/migration-labeler.yml
          sync-labels: false

      - name: ðŸ·ï¸ Set Migration Label Output
        id: set_label_output
        run: |
          if [ "${{ steps.check_migrations.outputs.has_migrations }}" = "true" ]; then
            echo "has_migrations_label=true" >> $GITHUB_OUTPUT
          else
            echo "has_migrations_label=false" >> $GITHUB_OUTPUT
          fi

  migrate:
    needs: [prepare, build, label-migrations]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
      pull-requests: read
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for migration detection

      - name: ðŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.prepare.outputs.workload_identity_provider }}
          service_account: ${{ needs.prepare.outputs.github_actions_service_account }}

      - name: âš™ï¸ Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'

      - name: ðŸ” Check Migration Label on PR
        id: check_label
        if: inputs.migrations_require_label == true && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const labelName = 'migrations';
            const prNumber = context.payload.pull_request.number;
            
            try {
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              const hasLabel = labels.some(label => label.name === labelName);
              core.setOutput('has_label', hasLabel.toString());
              
              if (hasLabel) {
                console.log(`âœ… Migration label "${labelName}" found on PR #${prNumber}`);
              } else {
                console.log(`â„¹ï¸ Migration label "${labelName}" not found on PR #${prNumber}`);
              }
            } catch (error) {
              console.error(`âŒ Error checking label: ${error.message}`);
              core.setOutput('has_label', 'false');
            }

      - name: ðŸ” Set Default Label Check Output
        id: default_label_check
        if: inputs.migrations_require_label != true || github.event_name != 'pull_request'
        run: |
          echo "has_label=false" >> $GITHUB_OUTPUT

      - name: ðŸ” Determine if Migrations Should Run
        id: should_run_migrations
        env:
          LABEL_CHECK_HAS_LABEL: ${{ steps.check_label.outputs.has_label }}
          DEFAULT_LABEL_CHECK_HAS_LABEL: ${{ steps.default_label_check.outputs.has_label }}
          MIGRATIONS_LABEL_DETECTED: ${{ needs.label-migrations.outputs.has_migrations_label }}
        run: |
          # Get label check result (defaults to false if step didn't run)
          LABEL_CHECK_RESULT="${LABEL_CHECK_HAS_LABEL:-${DEFAULT_LABEL_CHECK_HAS_LABEL:-false}}"
          # Get migration detection result from label-migrations job
          MIGRATIONS_DETECTED="${MIGRATIONS_LABEL_DETECTED:-false}"
          
          if [ "${{ inputs.migrations_require_label }}" = "true" ]; then
            echo "ðŸ” Label-based migration control is ENABLED"
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              # For PRs, check if label is present
              if [ "$LABEL_CHECK_RESULT" = "true" ]; then
                echo "âœ… Migration label found - migrations will run"
                echo "should_run=true" >> $GITHUB_OUTPUT
              else
                echo "â­ï¸ Migration label not found - migrations will be skipped"
                echo "should_run=false" >> $GITHUB_OUTPUT
              fi
            else
              # For non-PR events, use output from label-migrations job
              if [ "$MIGRATIONS_DETECTED" = "true" ]; then
                echo "âœ… Migration changes detected - migrations will run"
                echo "should_run=true" >> $GITHUB_OUTPUT
              else
                echo "â­ï¸ No migration changes detected - migrations will be skipped"
                echo "should_run=false" >> $GITHUB_OUTPUT
              fi
            fi
          else
            echo "ðŸ” Label-based migration control is DISABLED - using file detection"
            # Use file detection from label-migrations job
            if [ "$MIGRATIONS_DETECTED" = "true" ]; then
              echo "âœ… Migration files changed - migrations will run"
              echo "should_run=true" >> $GITHUB_OUTPUT
            else
              echo "â­ï¸ No migration files changed - migrations will be skipped"
              echo "should_run=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: ðŸ—„ï¸ Run Database Migrations for ${{ matrix.label }}
        if: steps.should_run_migrations.outputs.should_run == 'true'
        run: |
          echo "Running migrations for region: ${{ matrix.region }}, label: ${{ matrix.label }}"
          
          PROJECT_ID="${{ needs.prepare.outputs.project_id }}"
          JOB_NAME="${{ matrix.migration_job_name }}"
          
          if [ -z "$JOB_NAME" ] || [ "$JOB_NAME" = "null" ]; then
            echo "âŒ Migration job name not found for label ${{ matrix.label }}"
            echo "âš ï¸  Make sure migration_job_name is set in deployment config for this service"
            exit 1
          fi
          
          echo "Using migration job: $JOB_NAME"
          echo "Region: ${{ matrix.region }}"
          
          # Execute migration job - ENTRYPOINT_MODE=migrate is already set in the job definition
          echo "Executing migration job: $JOB_NAME"
          if ! gcloud run jobs execute "$JOB_NAME" \
            --region "${{ matrix.region }}" \
            --project "$PROJECT_ID" \
            --wait; then
            echo "âŒ Migration job execution failed"
            echo "ðŸ“‹ View logs: gcloud run jobs executions list --job=$JOB_NAME --region=${{ matrix.region }} --project=$PROJECT_ID"
            exit 1
          fi
          
          echo "âœ… Migrations completed successfully for ${{ matrix.label }}"

      - name: â­ï¸ Skip Migrations
        if: steps.should_run_migrations.outputs.should_run == 'false'
        run: |
          if [ "${{ inputs.migrations_require_label }}" = "true" ]; then
            echo "â­ï¸ Skipping migrations - migration label not present (label-based control enabled)"
          else
            echo "â­ï¸ Skipping migrations - no migration files changed"
          fi

  deploy:
    needs: [prepare, build, migrate]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
      packages: read
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: ðŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.prepare.outputs.workload_identity_provider }}
          service_account: ${{ needs.prepare.outputs.github_actions_service_account }}

      - name: âš™ï¸ Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '502.0.0'

      - name: ðŸš€ Deploy ${{ matrix.service_name }} to ${{ matrix.region }}
        run: |
          echo "Deploying ${{ matrix.service_name }} to region ${{ matrix.region }}"
          echo "Label: ${{ matrix.label }}"
          
          # Reuse variables from prepare job
          PROJECT_ID="${{ needs.prepare.outputs.project_id }}"
          PROJECT_NUMBER="${{ needs.prepare.outputs.project_number }}"
          ARTIFACT_REGISTRY_HOST="${{ needs.prepare.outputs.artifact_registry }}"
          ARTIFACT_REGISTRY_REPOSITORY="${{ needs.prepare.outputs.repository }}"
          IMAGE_TAG="${{ needs.prepare.outputs.image_tag }}"
          
          # Use image_name from service matrix
          echo "Using image from service matrix: ${{ matrix.image_name }}"
          
          # Construct image path using image_name from service matrix
          IMAGE="${ARTIFACT_REGISTRY_HOST}/${PROJECT_ID}/${ARTIFACT_REGISTRY_REPOSITORY}/${{ matrix.image_name }}"
          
          # Determine DEPLOY_REGION based on label
          if [ "${{ matrix.label }}" = "europe" ] || [ "${{ matrix.label }}" = "eu" ]; then
            DEPLOY_REGION="europe"
          else
            DEPLOY_REGION="default"
          fi
          
          # Build env vars string (only update what's needed, preserve existing Cloud Run vars like K_SERVICE, K_REVISION, PORT, GOOGLE_CLOUD_PROJECT)
          # Use environment variables for entrypoint configuration (ENTRYPOINT_MODE, ENTRYPOINT_PROVIDER)
          ENV_VARS="GOOGLE_CLOUD_PROJECT_NUMBER=$PROJECT_NUMBER,GOOGLE_CLOUD_PROJECT_ID=$PROJECT_ID,DEPLOY_REGION=$DEPLOY_REGION,ENTRYPOINT_MODE=serve,ENTRYPOINT_PROVIDER=gcp"
          
          gcloud run services update "${{ matrix.service_name }}" \
            --image "$IMAGE:$IMAGE_TAG" \
            --region "${{ matrix.region }}" \
            --project "$PROJECT_ID" \
            --update-env-vars "$ENV_VARS"

      - name: ðŸ“Š Deployment Summary for ${{ matrix.label }}
        run: |
          ARTIFACT_REGISTRY_HOST="${{ needs.prepare.outputs.artifact_registry }}"
          PROJECT_ID="${{ needs.prepare.outputs.project_id }}"
          ARTIFACT_REGISTRY_REPOSITORY="${{ needs.prepare.outputs.repository }}"
          IMAGE_PATH="${ARTIFACT_REGISTRY_HOST}/${PROJECT_ID}/${ARTIFACT_REGISTRY_REPOSITORY}/${{ matrix.image_name }}"
          
          echo "### ðŸš€ Cloud Run Deployment - ${{ matrix.label }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** ${{ matrix.service_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ matrix.region }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${IMAGE_PATH}:${{ needs.prepare.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY

